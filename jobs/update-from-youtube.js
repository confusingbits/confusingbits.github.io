const fs = require("fs");
const path = require("path");
const key = process.env.GOOGLE_API_KEY;
const channelId = "UC2od81AMlgwctg2hCfVSe_A";
const dir = "../content/blog";
const { spawnSync } = require("child_process");
const he = require("he");
const { convert } = require("html-to-text");
const linkify = require("linkifyjs");
var slugify = require('slugify')

const handle = async (dir, fs, path) => {
  // use git to find the last updated blog post, we can then only fetch videos after that date
  const proc = spawnSync("git", [
    "log",
    "-1",
    "--format=%ct",
    "../content/blog/",
  ]);
  // const lastTs = 1310052127; // for all videos on channel
  const lastTs = proc.stdout.toString();
  const lastDate = new Date(lastTs * 1000);

  let items = [];
  let nextPageToken = ""; // need to handle pagination since it is possible to have more than 50 videos
  while (nextPageToken !== undefined) {
    // https://developers.google.com/youtube/v3/docs/search
    const res = await fetch(
      `https://youtube.googleapis.com/youtube/v3/search?&key=${key}&order=date&channelId=${channelId}&part=snippet&maxResults=50&publishedAfter=${lastDate.toISOString()}&pageToken=${nextPageToken}`
    );
    const json = await res.json();
    items = items.concat(json.items);
    nextPageToken = json.nextPageToken;
  }

  const promises = items.map(async (item) => {
    const title = he.decode(item.snippet.title);
    const slug = slugify(title, {lower: true, strict: true})
      .replace(/^[\d*-]*/g, ""); // remove any leading numbers or dashes because elm doesn't like that in types, and the urls are types
    const response = await fetch(item.snippet.thumbnails.high.url);

    const blob = await response.blob();

    const arrayBuffer = await blob.arrayBuffer();

    const buffer = Buffer.from(arrayBuffer);

    fs.writeFileSync(`../images/${slug}.jpg`, buffer);

    const res = await fetch(`https://youtu.be/${item.id.videoId}&lang=en`);
    const html = await res.text();
    const start = html.indexOf("https://www.youtube.com/api/timedtext?");
    const substr = [...html.substring(start, start + 500)];

    let urlArr = [];
    urlArr.push('"');
    for (let c of substr) {
      if (c === '"') {
        urlArr.push('"');
        break;
      }
      urlArr.push(c);
    }

    let b = "";
    let description = "";
    try {
      const url = JSON.parse(urlArr.join(""));
      const res2 = await fetch(url);
      const text = await res2.text();

      // convert the <text> to plain text
      const body = convert(text, {
        selectors: [
          {
            selector: "text",
            format: "block",
            options: { leadingLineBreaks: 2, trailingLineBreaks: 2 },
          },
        ],
      }).replace(/uh\s|um\s/g, ""); // remove uh's and um's

      // create a markdown link for each link in the description
      const descriptionLinks = linkify.find(item.snippet.description);
      let lastIndex = 0;
      for (let link of descriptionLinks) {
        description += item.snippet.description.substring(
          lastIndex,
          link.start
        );
        description += `[${link.href}](${link.value})`;
        lastIndex = link.end;
      }
      // put the text in quote blocks
      b = ">" + body.replace(/\n\n/g, "\n>\n> ");
    } catch (e) {
      console.log(e);
    }

    fs.writeFileSync(
      `../content/blog/${slug}.md`,
      `---
type: blog
author: Corey Thompson
title: >
  ${he.decode(item.snippet.title)}
description: >
  An automatic transcription of the youtube video, ${
    item.snippet.title
  }, generated from youtube captions.
image: images/${slug}.jpg
published: "${item.snippet.publishedAt.split("T")[0]}"
video: https://www.youtube.com/watch?v=${item.id.videoId}
---

${description}

### Transcript

*This transcript was automatically generated by YouTube, so there may (will) be some (many) errors.*

${b}
`
    );
  });
  await Promise.all(promises);
};

handle(dir, fs, path)
  .then(() => {
    console.log("done");
    process.exit(0);
  })
  .catch((e) => {
    console.error(e.message);
    process.exit(1);
  });
